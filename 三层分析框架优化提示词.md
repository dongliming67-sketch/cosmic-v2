# COSMIC 三层分析框架 - 优化提示词系统

## 核心理念：从"直接输出表格"到"三层思考+四步流水线"

### 问题诊断
传统方法让大模型直接输出最终表格，导致：
1. **FP边界模糊**：将系统内部子步骤错误拆成独立FP
2. **数据组重复**：属性组合雷同（如反复出现"标识、编号"）
3. **拆分不全**：文档描述简单时无法合理膨胀

### 解决方案：三层分析 + 四步流水线

---

## 第一阶段：识别功能用户与触发事件（确定 FP 边界）

### 核心原则
**COSMIC 规定**：一个功能过程（FP）必须由一个功能用户发起的触发事件启动。

### 分析指令

```markdown
## 任务：识别所有外部交互者及其触发动作

### 步骤1：扫描文档，列出所有边界交互者
- **人类用户**：操作界面、点击按钮、输入数据的角色
- **外部系统**：调用本系统接口、推送数据的其他平台
- **定时器**：按时间自动执行的调度器

### 步骤2：为每个交互者列出其发起的动作
格式：[交互者类型] - [动作描述] - [触发方式]

示例：
- 用户 - 点击"创建任务"按钮 - 用户触发
- 用户 - 点击"批量加工"按钮（后台异步执行） - 用户触发（注意：虽然后台执行，但触发源是用户）
- 定时触发器 - 每日凌晨3点自动清理过期数据 - 时钟触发
- 外部监控平台 - 推送告警信息到本系统 - 接口触发

### 步骤3：排除非功能过程
以下情况**不是**独立的FP：
- ❌ 单纯的数据校验（如"验证参数格式"）
- ❌ 内部查询步骤（如"查询用户权限"作为其他功能的子步骤）
- ❌ 被动存储（如"数据库自动备份"）
- ❌ UI渲染（如"页面加载动画"）

### 输出格式
以JSON格式输出：
{
  "functionalUsers": [
    {
      "userType": "用户触发/时钟触发/接口触发",
      "triggeringEvents": [
        {
          "eventName": "创建飞行任务",
          "eventDescription": "用户在任务管理界面点击'新增任务'按钮",
          "dataObjectsInvolved": ["任务", "航线", "无人机"]
        }
      ]
    }
  ]
}
```

### 效果
防止将系统内部的子步骤（如单纯的校验或内部查询）错误地拆成独立的 FP。

---

## 第二阶段：识别数据对象（确定数据组边界）

### 核心原则
**数据移动必须针对某个"数据对象"**。每个数据对象都有明确的属性集合。

### 分析指令

```markdown
## 任务：提取所有数据实体及其字段池

### 步骤1：扫描文档中的所有表格、接口说明、数据结构
重点关注：
- 输入参数表
- 输出结果表
- 数据库表结构
- 接口字段说明

### 步骤2：为每个数据实体建立字段池
格式：[实体名称] - [字段列表（使用文档中的原始英文字段名）]

示例：
- 飞行任务实体：
  - task_id（任务标识）
  - task_name（任务名称）
  - flight_route_id（航线ID）
  - drone_id（无人机ID）
  - scheduled_time（计划起飞时间）
  - task_status（任务状态）
  - create_time（创建时间）
  - creator_id（创建人ID）
  - priority_level（优先级）

- 航线实体：
  - route_id（航线标识）
  - route_name（航线名称）
  - start_point（起点坐标）
  - end_point（终点坐标）
  - waypoints（航点列表）
  - route_type（航线类型）

### 步骤3：识别"规则生成"字段
文档中标注为"规则生成"的字段，背后隐含：
- 一个 Read (R)：读取规则配置
- 一个 Write (W)：写入生成结果

必须找出数据源并补齐该子过程。

### 步骤4：建立实体关系图
标注实体之间的关联关系（1对1、1对多、多对多）

### 输出格式
以JSON格式输出：
{
  "dataObjects": [
    {
      "objectName": "飞行任务",
      "englishName": "FlightTask",
      "fieldPool": [
        {"fieldName": "task_id", "fieldType": "string", "description": "任务唯一标识"},
        {"fieldName": "task_name", "fieldType": "string", "description": "任务名称"},
        {"fieldName": "flight_route_id", "fieldType": "string", "description": "关联的航线ID"},
        {"fieldName": "scheduled_time", "fieldType": "datetime", "description": "计划起飞时间"}
      ],
      "relatedObjects": ["航线", "无人机", "操作员"]
    }
  ]
}
```

### 效果
解决数据组模糊的问题，确保每个移动都有明确的"家"。

---

## 第三阶段：执行 ERWX 闭环填充（确定移动粒度）

### 核心原则
对于每个 FP，**强制要求**它寻找数据是怎么进来的 (E)、参考了什么 (R)、存到了哪 (W)、反馈了什么 (X)。

### 分析指令

```markdown
## 任务：为每个功能过程填充完整的 ERWX 闭环

### 铁律
1. **每个FP必须有且仅有1个E**：数据跨边界进入
2. **每个FP必须至少有1个R**：读取支撑数据
3. **每个FP必须至少有1个W**：持久化结果
4. **每个FP必须有且仅有1个X**：数据跨边界返回

### 严禁的情况
- ❌ 只有 E + X（缺少 R 和 W）
- ❌ 只有 E + R + X（缺少 W）
- ❌ 只有 E + W + X（缺少 R）

### 特殊情况处理

#### 查询类功能
即使是纯查询，也必须有 W：
- W = 记录查询日志（查询人、查询时间、查询条件）

#### 简单操作
即使是简单的删除操作，也必须有 R：
- R = 读取当前状态（验证是否可删除、读取关联数据）

#### 文档未明确写 X 的情况
推导默认的 X：
- 成功提示："操作成功，返回结果ID"
- 失败提示："操作失败，返回错误码和错误信息"

### ERWX 详细填充规则

#### E (Entry - 接收/门卫)
**职责**：接收原始请求、解析协议头、校验调用者身份、解析入口字段

**命名公式**：接收 + [场景化业务对象] + [协议类型/数据形态] + 指令/包

**属性要求**：
- 必须包含：请求标识（request_id）、触发源标识、核心业务ID、请求时间戳
- 必须使用文档中定义的具体字段（不能自造通用字段）

**示例**：
- 子过程描述：接收飞行任务创建请求参数包
- 数据组：飞行任务创建请求参数集
- 数据属性：request_id, task_name, flight_route_id, drone_id, scheduled_time, creator_id, request_timestamp

#### R (Read - 读取/大脑)
**职责**：从数据库检索业务配置、对齐标准字典、检查历史状态、读取审计规则

**命名公式**：检索/读取 + [业务状态/字典] + [关联关系] + 集合/数据

**属性要求**：
- 必须包含：查询条件字段、返回的关键业务字段
- 必须体现该功能特定需要读取的数据（不能泛化为"读取所有信息"）

**示例**：
- 子过程描述：读取可分配航线库和无人机资源状态
- 数据组：可分配航线与无人机资源池
- 数据属性：route_id, route_name, route_status, drone_id, drone_status, current_location, battery_level, maintenance_schedule

#### W (Write - 写入/执行)
**职责**：更新业务主表、原子化写入操作日志、持久化中间态数据、锁定业务资源

**命名公式**：持久化/记录/更新 + [更新行为] + [表族名] + 事务流水/日志

**属性要求**：
- 必须包含：更新后的状态字段、操作时间、执行日志、版本号
- 必须体现该功能写入的具体内容（不能泛化为"保存数据"）

**示例**：
- 子过程描述：保存飞行任务初始配置和资源绑定关系
- 数据组：飞行任务初始配置持久化数据表
- 数据属性：task_id, task_name, task_status, bound_route_id, bound_drone_id, create_time, creator_id, version_no

#### X (eXit - 输出/反馈)
**职责**：封装标准响应协议体、映射层级化错误码、记录接口处理耗时

**命名公式**：封装/返回 + [响应等级] + [返回码映射] + 响应体/凭证

**属性要求**：
- 必须包含：返回码（result_code）、提示语（message）、业务处理回执、响应时间戳
- 必须体现该功能返回的具体结果（不能泛化为"返回结果"）

**示例**：
- 子过程描述：返回飞行任务创建成功凭证和资源分配清单
- 数据组：飞行任务创建确认回执
- 数据属性：result_code, message, task_id, task_status, bound_route_info, bound_drone_info, create_timestamp, response_timestamp

### 输出格式
以JSON格式输出：
{
  "functionalProcesses": [
    {
      "fpName": "创建飞行任务",
      "userType": "用户触发",
      "triggerEvent": "用户请求",
      "subProcesses": [
        {
          "type": "E",
          "description": "接收飞行任务创建请求参数包",
          "dataGroup": "飞行任务创建请求参数集",
          "attributes": ["request_id", "task_name", "flight_route_id", "drone_id", "scheduled_time", "creator_id", "request_timestamp"]
        },
        {
          "type": "R",
          "description": "读取可分配航线库和无人机资源状态",
          "dataGroup": "可分配航线与无人机资源池",
          "attributes": ["route_id", "route_name", "route_status", "drone_id", "drone_status", "current_location", "battery_level"]
        },
        {
          "type": "W",
          "description": "保存飞行任务初始配置和资源绑定关系",
          "dataGroup": "飞行任务初始配置持久化数据表",
          "attributes": ["task_id", "task_name", "task_status", "bound_route_id", "bound_drone_id", "create_time", "creator_id"]
        },
        {
          "type": "X",
          "description": "返回飞行任务创建成功凭证和资源分配清单",
          "dataGroup": "飞行任务创建确认回执",
          "attributes": ["result_code", "message", "task_id", "task_status", "bound_route_info", "bound_drone_info", "create_timestamp"]
        }
      ]
    }
  ]
}
```

### 效果
确保每个FP内部包含完整的数据流转闭环，不会出现只有E或只有W的情况。

---

## 第四阶段：数据属性唯一性去重算法

### 核心原则
**每个功能过程的属性组合必须在物理上是唯一的**，禁止在不同 FP 中使用完全相同的 Data Group + Attributes 组合。

### 去重策略

#### 1. 实体优先规则
**禁止自定义通用属性，必须 100% 采用文档表格中定义的具体字段。**

示例：
- ❌ 错误：使用"标识、编号、名称、状态"等通用字段
- ✅ 正确：使用"task_id, task_name, flight_route_id, scheduled_time"等文档定义的具体字段

#### 2. 属性指纹校验
**每个功能过程的属性组合必须与其他过程至少有 3 处具体字段的差异。**

算法：
```
对于功能过程 FP_A 和 FP_B：
  属性集合_A = FP_A 的所有数据属性（E + R + W + X）
  属性集合_B = FP_B 的所有数据属性（E + R + W + X）
  
  交集 = 属性集合_A ∩ 属性集合_B
  重合度 = len(交集) / min(len(属性集合_A), len(属性集合_B))
  
  如果 重合度 > 70%：
    报警：FP_A 和 FP_B 的属性组合过于相似，需要调整
```

#### 3. 核心字段 + 随机辅助字段的动态组合

**步骤1：核心字段占位**
根据FP的含义分配专属字段：
- 涉及任务：必选 task_id, task_name, task_status
- 涉及航线：必选 route_id, route_name, waypoints
- 涉及设备：必选 device_id, device_sn, device_type

**步骤2：辅助字段填充**
从通用字段池中随机抽取，确保不同FP使用不同的辅助字段组合：
- 通用字段池：create_time, update_time, operator_id, operator_name, version_no, retry_count, source_system, target_system, request_id, response_id, error_code, error_message

**步骤3：字段互斥原则**
同一表格中，相邻的两个功能过程，其数据属性重合度不得超过30%。

示例：
```
FP1: 创建飞行任务
  E: request_id, task_name, flight_route_id, drone_id, scheduled_time, creator_id, request_timestamp
  R: route_id, route_name, route_status, drone_id, drone_status, battery_level
  W: task_id, task_name, task_status, bound_route_id, bound_drone_id, create_time, creator_id
  X: result_code, message, task_id, task_status, bound_route_info, create_timestamp

FP2: 启用暂停的飞行任务
  E: task_id, resume_operator_id, resume_time, pause_reason_code, estimated_completion_time
  R: task_id, pause_position, pause_altitude, pause_duration, completed_waypoints, device_status, battery_percentage
  W: task_id, status_transition_type, from_pause_to_running, transition_time, resume_operator, resume_reason
  X: task_id, resume_status, resume_time, current_position, estimated_completion, remaining_duration, confirmation_code

注意：FP1 和 FP2 的字段组合完全不同，重合度低于30%
```

#### 4. 规则生成字段检测
文档中标注为"规则生成"的字段，背后一定隐含：
- 一个 Read (R)：读取规则配置表
- 一个 Write (W)：写入生成结果表

必须找出数据源并补齐该子过程。

示例：
```
文档描述："根据规则生成任务编号"

拆解为：
R: 读取任务编号生成规则配置
   数据组：任务编号生成规则配置表
   属性：rule_id, rule_name, prefix_pattern, sequence_start, sequence_step, date_format

W: 写入生成的任务编号
   数据组：任务编号生成记录表
   属性：task_id, generated_code, generation_time, rule_id, sequence_no
```

### 输出格式
在最终输出Markdown表格前，先输出去重检查报告：

```json
{
  "deduplicationReport": {
    "totalFunctionalProcesses": 50,
    "duplicateWarnings": [
      {
        "fp1": "创建飞行任务",
        "fp2": "修改飞行任务",
        "overlapRate": 0.75,
        "suggestion": "建议调整'修改飞行任务'的属性组合，增加update_time, update_operator, update_reason等字段"
      }
    ],
    "uniquenessScore": 0.95
  }
}
```

---

## 第五阶段：解决"拆不全"的膨胀策略

### 当文档描述简单时，从三个维度进行"逻辑膨胀"

#### 1. 异常分支法
针对每个正向功能，强制拆出一个"异常攔截/校验失败"的 FP。

示例：
- 正向功能：创建飞行任务
- 异常分支：创建飞行任务参数校验失败处理
  - E: 接收参数校验失败通知
  - R: 读取参数校验规则配置
  - W: 记录参数校验失败日志
  - X: 返回参数校验失败错误信息

#### 2. 生命周期法
将一个接口拆分为不同阶段：

示例：
- 初始请求接收：创建飞行任务
- 异步结果回填：更新飞行任务执行结果
- 状态定时刷新：定时同步飞行任务状态

#### 3. 管理与审计维度
自动补齐系统级功能过程：

- 身份鉴权：验证用户操作权限
- 操作日志自动记录：记录所有操作审计日志
- 数据一致性检查：定时检查数据完整性

---

## 四步流水线实施方案

### Step 1：对象提取
**输入**：原始文档
**输出**：《数据对象与字段清单》（JSON格式）

### Step 2：功能过程清单生成
**输入**：数据对象清单 + 原始文档
**输出**：《50个不重复的功能过程清单（含触发事件说明）》（JSON格式）

### Step 3：细节填充（分批处理）
**输入**：功能过程清单（每次5个）+ 数据对象清单
**输出**：详细的 ERWX 和对应的数据组（JSON格式）

### Step 4：自我审计
**输入**：所有功能过程的完整拆分结果
**输出**：去重报告 + 修正后的Markdown表格

审计问题：
1. 这所有的功能中是否有重叠？
2. 是否有不符合数据移动定义的？
3. 每个FP是否都有完整的ERWX闭环？
4. 数据属性组合是否唯一？

---

## 核心指令总结

```
请不要将文档章节直接视为功能过程。

请以触发事件为导向，分析文档中标注为"规则生成"或"接口返回"的字段。

针对每个功能过程，必须精确提取文档输入/输出表中的原始英文字段作为数据属性，且确保每个功能过程的属性集在物理上是唯一的。

请确保每个 FP 内部包含完整的数据流转闭环（E、R、W、X）。

禁止自定义通用属性（如"标识、编号、名称"），必须100%采用文档表格中定义的具体字段（如city, schedule_type, run_count）。

每个功能过程的属性组合必须与其他过程至少有3处具体字段的差异。禁止在不同FP中使用完全相同的Data Group + Attributes组合。

凡是文档中标注为"规则生成"的字段，背后一定隐含着一个Read (R)和一个Write (W)动作。请找出数据源并补齐该子过程。
```

---

## 技术实施建议

### 如果使用智譜或 Gemini API，采用"多步 Pipeline"

#### Pipeline 架构
```
原始文档
    ↓
[Step 1] 对象提取 API
    ↓
数据对象与字段清单（JSON）
    ↓
[Step 2] 功能过程清单生成 API
    ↓
功能过程清单（JSON）
    ↓
[Step 3] 细节填充 API（分批，每次5个FP）
    ↓
详细ERWX拆分结果（JSON）
    ↓
[Step 4] 自我审计 API
    ↓
去重报告 + 最终Markdown表格
```

#### API 调用示例

**Step 1: 对象提取**
```javascript
POST /api/cosmic/extract-objects
{
  "documentContent": "...",
  "userGuidelines": "..."
}

Response:
{
  "dataObjects": [...],
  "fieldPools": {...}
}
```

**Step 2: 功能过程清单生成**
```javascript
POST /api/cosmic/generate-fp-list
{
  "documentContent": "...",
  "dataObjects": [...],
  "targetCount": 50
}

Response:
{
  "functionalProcesses": [
    {
      "fpName": "创建飞行任务",
      "userType": "用户触发",
      "triggerEvent": "用户请求",
      "dataObjectsInvolved": ["任务", "航线", "无人机"]
    }
  ]
}
```

**Step 3: 细节填充（分批）**
```javascript
POST /api/cosmic/fill-erwx-details
{
  "functionalProcesses": [...], // 每次5个
  "dataObjects": [...],
  "previousResults": [...] // 已完成的FP，用于去重
}

Response:
{
  "detailedFPs": [...]
}
```

**Step 4: 自我审计**
```javascript
POST /api/cosmic/self-audit
{
  "allFunctionalProcesses": [...]
}

Response:
{
  "deduplicationReport": {...},
  "correctedFPs": [...],
  "markdownTable": "..."
}
```

---

## 质量检查清单

### FP 边界检查
- [ ] 每个FP都由明确的触发事件启动
- [ ] 没有将内部子步骤错误拆成独立FP
- [ ] 排除了非功能过程（UI渲染、被动存储等）

### 数据对象检查
- [ ] 所有数据组都对应明确的业务实体
- [ ] 使用了文档中定义的原始字段名
- [ ] 建立了完整的字段池

### ERWX 闭环检查
- [ ] 每个FP都有且仅有1个E
- [ ] 每个FP至少有1个R
- [ ] 每个FP至少有1个W
- [ ] 每个FP都有且仅有1个X
- [ ] 查询类功能有W（记录日志）
- [ ] 简单操作有R（读取状态）

### 属性唯一性检查
- [ ] 没有使用通用属性（标识、编号等）
- [ ] 每个FP的属性组合与其他FP重合度<30%
- [ ] 识别并补齐了"规则生成"字段的R和W
- [ ] 相邻FP的属性组合有明显差异

### 完整性检查
- [ ] 覆盖了文档中的所有功能描述
- [ ] 补充了异常分支功能
- [ ] 补充了生命周期各阶段功能
- [ ] 补充了管理与审计功能

---

## 示例对比

### 传统方法（问题）
```markdown
| 功能用户 | 触发事件 | 功能过程 | 子过程描述 | 数据移动类型 | 数据组 | 数据属性 |
|:---|:---|:---|:---|:---|:---|:---|
| 用户 | 点击按钮 | 创建任务 | 接收请求 | E | 任务请求 | 标识、名称、状态 |
|||| 保存数据 | W | 任务表 | 标识、名称、状态 |
|||| 返回结果 | X | 任务响应 | 标识、状态 |
```

**问题**：
1. 缺少R（没有读取任何数据）
2. 属性过于通用（标识、名称、状态）
3. 数据组命名模糊（请求、表、响应）

### 三层分析方法（优化）
```markdown
| 功能用户 | 触发事件 | 功能过程 | 子过程描述 | 数据移动类型 | 数据组 | 数据属性 |
|:---|:---|:---|:---|:---|:---|:---|
| 用户触发 | 用户请求 | 创建新的飞行计划任务 | 接收新飞行计划任务创建表单数据 | E | 飞行计划任务新建表单提交数据 | request_id, task_name, flight_route_id, drone_id, scheduled_time, creator_id, priority_level, request_timestamp |
|||| 读取可用航线库和无人机资源分配情况 | R | 可分配航线与无人机资源池 | route_id, route_name, start_point, end_point, drone_id, current_location, battery_level, available_status, maintenance_schedule |
|||| 保存飞行计划任务初始配置和资源绑定关系 | W | 飞行计划任务初始配置持久化数据 | task_id, task_name, task_status, bound_route_id, bound_drone_id, create_time, creator_id, version_no |
|||| 返回飞行计划任务创建成功凭证和资源清单 | X | 飞行计划任务创建凭证与资源清单 | result_code, message, task_id, task_status, bound_route_info, bound_drone_info, priority_level, create_timestamp, response_timestamp |
```

**优势**：
1. 完整的ERWX闭环
2. 使用文档定义的具体字段
3. 数据组命名业务化
4. 属性组合唯一且丰富

---

## 结语

通过三层分析框架和四步流水线，可以：
1. **提高准确性**：确保FP边界清晰，不会将子步骤错误拆分
2. **提高唯一性**：确保数据属性组合在物理上唯一，避免重复
3. **提高完整性**：通过膨胀策略，合理拆分出更多功能过程
4. **提高质量**：通过自我审计，发现并修正问题

这套方法论特别适合复杂的业务系统（如低空飞行管理、网络优化等），能够将线性文档重构为立体的功能模型。
