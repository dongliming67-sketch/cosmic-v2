# 三层分析框架 - 实施指南

## 概述

本指南说明如何在现有系统中集成三层分析框架，提升COSMIC拆分质量。

## 核心改进点

### 1. 从"直接输出表格"到"三层思考"

**传统方法问题**：
- FP边界模糊：将系统内部子步骤错误拆成独立FP
- 数据组重复：属性组合雷同（如反复出现"标识、编号"）
- 拆分不全：文档描述简单时无法合理膨胀

**三层分析解决方案**：
1. **第一层**：识别功能用户与触发事件（确定FP边界）
2. **第二层**：识别数据对象（确定数据组边界）
3. **第三层**：执行ERWX闭环填充（确定移动粒度）

### 2. 四步流水线架构

```
原始文档
    ↓
[Step 1] 对象提取 API
    ↓
数据对象与字段清单（JSON）
    ↓
[Step 2] 功能过程清单生成 API
    ↓
功能过程清单（JSON）
    ↓
[Step 3] 细节填充 API（分批，每次5个FP）
    ↓
详细ERWX拆分结果（JSON）
    ↓
[Step 4] 自我审计 API
    ↓
去重报告 + 最终Markdown表格
```

## 集成步骤

### 步骤1：更新系统提示词

在 `server/index.js` 中，替换现有的 `COSMIC_SYSTEM_PROMPT` 为增强版：

```javascript
const { ENHANCED_COSMIC_SYSTEM_PROMPT } = require('./enhanced-prompts');

// 替换原有的 COSMIC_SYSTEM_PROMPT
const COSMIC_SYSTEM_PROMPT = ENHANCED_COSMIC_SYSTEM_PROMPT;
```

### 步骤2：添加四步流水线API端点

在 `server/index.js` 中添加以下API端点：

```javascript
const {
  STEP1_OBJECT_EXTRACTION_PROMPT,
  STEP2_FP_LIST_GENERATION_PROMPT,
  STEP3_ERWX_DETAIL_FILLING_PROMPT,
  STEP4_SELF_AUDIT_PROMPT
} = require('./enhanced-prompts');

// Step 1: 对象提取
app.post('/api/cosmic/extract-objects', async (req, res) => {
  try {
    const { documentContent, userGuidelines = '' } = req.body;
    
    const client = getOpenAIClient();
    if (!client) {
      return res.status(400).json({ error: '请先配置API密钥' });
    }

    const prompt = `${STEP1_OBJECT_EXTRACTION_PROMPT}

${userGuidelines ? `\n## 用户特定要求\n${userGuidelines}\n` : ''}

## 需求文档
${documentContent}

请分析上述文档，提取所有数据对象及其字段池。`;

    const completion = await client.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一个数据建模专家。请只输出JSON格式，不要有其他文字。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      max_tokens: 4000
    });

    const content = completion.choices[0].message.content;
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    const result = jsonMatch ? JSON.parse(jsonMatch[0]) : { dataObjects: [] };

    res.json({
      success: true,
      dataObjects: result.dataObjects || [],
      entityRelationships: result.entityRelationships || []
    });
  } catch (error) {
    console.error('对象提取失败:', error);
    res.status(500).json({ error: '对象提取失败: ' + error.message });
  }
});

// Step 2: 功能过程清单生成
app.post('/api/cosmic/generate-fp-list', async (req, res) => {
  try {
    const { documentContent, dataObjects, targetCount = 50, userGuidelines = '' } = req.body;
    
    const client = getOpenAIClient();
    if (!client) {
      return res.status(400).json({ error: '请先配置API密钥' });
    }

    const dataObjectsSummary = dataObjects.map(obj => 
      `- ${obj.objectName}（${obj.englishName}）：${obj.fieldPool.businessFields.length}个业务字段`
    ).join('\n');

    const prompt = `${STEP2_FP_LIST_GENERATION_PROMPT}

${userGuidelines ? `\n## 用户特定要求\n${userGuidelines}\n` : ''}

## 数据对象清单
${dataObjectsSummary}

## 需求文档
${documentContent}

请分析上述文档，生成约${targetCount}个功能过程清单。`;

    const completion = await client.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一个COSMIC功能过程识别专家。请只输出JSON格式，不要有其他文字。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.4,
      max_tokens: 6000
    });

    const content = completion.choices[0].message.content;
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    const result = jsonMatch ? JSON.parse(jsonMatch[0]) : { functionalProcesses: [] };

    res.json({
      success: true,
      functionalProcesses: result.functionalProcesses || [],
      totalCount: result.totalCount || 0,
      breakdown: result.breakdown || {}
    });
  } catch (error) {
    console.error('功能过程清单生成失败:', error);
    res.status(500).json({ error: '功能过程清单生成失败: ' + error.message });
  }
});

// Step 3: ERWX细节填充（分批处理）
app.post('/api/cosmic/fill-erwx-details', async (req, res) => {
  try {
    const { functionalProcesses, dataObjects, previousResults = [] } = req.body;
    
    const client = getOpenAIClient();
    if (!client) {
      return res.status(400).json({ error: '请先配置API密钥' });
    }

    // 构建已完成的FP摘要（用于去重）
    const completedSummary = previousResults.map(fp => 
      `- ${fp.fpName}: ${fp.subProcesses.map(sp => sp.attributes.join(', ')).join(' | ')}`
    ).join('\n');

    const fpList = functionalProcesses.map(fp => 
      `- ${fp.fpName}（${fp.userType}）：涉及${fp.dataObjectsInvolved.join('、')}`
    ).join('\n');

    const prompt = `${STEP3_ERWX_DETAIL_FILLING_PROMPT}

## 待填充的功能过程
${fpList}

## 已完成的功能过程（避免重复）
${completedSummary || '无'}

请为上述功能过程填充详细的ERWX子过程。`;

    const completion = await client.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一个COSMIC数据移动分析专家。请只输出JSON格式，不要有其他文字。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.5,
      max_tokens: 8000
    });

    const content = completion.choices[0].message.content;
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    const result = jsonMatch ? JSON.parse(jsonMatch[0]) : { detailedFPs: [] };

    res.json({
      success: true,
      detailedFPs: result.detailedFPs || []
    });
  } catch (error) {
    console.error('ERWX细节填充失败:', error);
    res.status(500).json({ error: 'ERWX细节填充失败: ' + error.message });
  }
});

// Step 4: 自我审计
app.post('/api/cosmic/self-audit', async (req, res) => {
  try {
    const { allFunctionalProcesses } = req.body;
    
    const client = getOpenAIClient();
    if (!client) {
      return res.status(400).json({ error: '请先配置API密钥' });
    }

    const fpSummary = allFunctionalProcesses.map((fp, idx) => 
      `${idx + 1}. ${fp.fpName}（${fp.userType}）：${fp.subProcesses.length}个子过程`
    ).join('\n');

    const prompt = `${STEP4_SELF_AUDIT_PROMPT}

## 所有功能过程
${fpSummary}

## 详细数据
${JSON.stringify(allFunctionalProcesses, null, 2)}

请对上述功能过程进行全面审计。`;

    const completion = await client.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'glm-4-flash',
      messages: [
        { role: 'system', content: '你是一个COSMIC质量审计专家。请只输出JSON格式，不要有其他文字。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      max_tokens: 6000
    });

    const content = completion.choices[0].message.content;
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    const result = jsonMatch ? JSON.parse(jsonMatch[0]) : { auditReport: {}, correctedFPs: [] };

    // 将JSON结果转换为Markdown表格
    const markdownTable = convertToMarkdownTable(result.correctedFPs.length > 0 ? result.correctedFPs : allFunctionalProcesses);

    res.json({
      success: true,
      auditReport: result.auditReport || {},
      correctedFPs: result.correctedFPs || [],
      markdownTable: markdownTable
    });
  } catch (error) {
    console.error('自我审计失败:', error);
    res.status(500).json({ error: '自我审计失败: ' + error.message });
  }
});

// 辅助函数：将JSON转换为Markdown表格
function convertToMarkdownTable(functionalProcesses) {
  let table = '|功能用户|触发事件|功能过程|子过程描述|数据移动类型|数据组|数据属性|\n';
  table += '|:---|:---|:---|:---|:---|:---|:---|\n';
  
  functionalProcesses.forEach(fp => {
    fp.subProcesses.forEach((sp, idx) => {
      const row = [
        idx === 0 ? fp.userType : '',
        idx === 0 ? fp.triggerEvent : '',
        idx === 0 ? fp.fpName : '',
        sp.description,
        sp.type,
        sp.dataGroup,
        sp.attributes.join(', ')
      ];
      table += `|${row.join('|')}|\n`;
    });
  });
  
  return table;
}
```

### 步骤3：更新前端调用逻辑

在前端添加"四步流水线"模式选项：

```javascript
// 在 client/src/App.jsx 中添加

const [pipelineMode, setPipelineMode] = useState(false);
const [pipelineStep, setPipelineStep] = useState(0);
const [pipelineData, setPipelineData] = useState({
  dataObjects: [],
  functionalProcesses: [],
  detailedFPs: []
});

// 四步流水线执行函数
const executePipeline = async () => {
  try {
    // Step 1: 对象提取
    setPipelineStep(1);
    const objectsRes = await fetch('/api/cosmic/extract-objects', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        documentContent: documentText,
        userGuidelines: userGuidelines 
      })
    });
    const objectsData = await objectsRes.json();
    setPipelineData(prev => ({ ...prev, dataObjects: objectsData.dataObjects }));

    // Step 2: 功能过程清单生成
    setPipelineStep(2);
    const fpListRes = await fetch('/api/cosmic/generate-fp-list', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        documentContent: documentText,
        dataObjects: objectsData.dataObjects,
        targetCount: 50,
        userGuidelines: userGuidelines 
      })
    });
    const fpListData = await fpListRes.json();
    setPipelineData(prev => ({ ...prev, functionalProcesses: fpListData.functionalProcesses }));

    // Step 3: ERWX细节填充（分批处理）
    setPipelineStep(3);
    const batchSize = 5;
    const detailedFPs = [];
    for (let i = 0; i < fpListData.functionalProcesses.length; i += batchSize) {
      const batch = fpListData.functionalProcesses.slice(i, i + batchSize);
      const detailRes = await fetch('/api/cosmic/fill-erwx-details', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          functionalProcesses: batch,
          dataObjects: objectsData.dataObjects,
          previousResults: detailedFPs
        })
      });
      const detailData = await detailRes.json();
      detailedFPs.push(...detailData.detailedFPs);
    }
    setPipelineData(prev => ({ ...prev, detailedFPs }));

    // Step 4: 自我审计
    setPipelineStep(4);
    const auditRes = await fetch('/api/cosmic/self-audit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ allFunctionalProcesses: detailedFPs })
    });
    const auditData = await auditRes.json();

    // 显示最终结果
    setAiResponse(auditData.markdownTable);
    parseMarkdownTable(auditData.markdownTable);
    
    setPipelineStep(0);
  } catch (error) {
    console.error('流水线执行失败:', error);
    setPipelineStep(0);
  }
};
```

## 使用建议

### 模式选择

1. **快速模式（现有方式）**：
   - 适用于：文档结构清晰、字段定义明确的场景
   - 优点：速度快，一次性输出
   - 缺点：可能出现属性重复、FP边界不清

2. **质量模式（三层分析框架）**：
   - 适用于：复杂业务系统、需要高质量拆分的场景
   - 优点：FP边界清晰、属性唯一、拆分完整
   - 缺点：需要多次API调用，耗时较长

3. **流水线模式（四步流水线）**：
   - 适用于：大型项目、需要精细控制的场景
   - 优点：可控性强、质量最高、可中断恢复
   - 缺点：需要最多的API调用和时间

### 最佳实践

1. **文档准备**：
   - 确保文档包含详细的字段定义（最好是表格形式）
   - 明确标注"规则生成"字段
   - 提供接口输入/输出参数说明

2. **参数调整**：
   - `targetCount`：根据文档复杂度调整目标功能数量
   - `batchSize`：Step 3 的批处理大小，建议5-10个
   - `temperature`：降低温度可提高一致性，建议0.3-0.5

3. **质量检查**：
   - 检查审计报告中的 `uniquenessScore`，应>0.85
   - 关注 `duplicateWarnings`，及时调整重复的FP
   - 验证每个FP都有完整的ERWX闭环

## 性能优化

### API调用优化

1. **批量处理**：Step 3 使用批量处理，减少API调用次数
2. **并行处理**：可以将多个批次并行处理（注意API限流）
3. **缓存机制**：缓存 Step 1 和 Step 2 的结果，避免重复计算

### 成本控制

1. **Token优化**：
   - Step 1: ~4000 tokens
   - Step 2: ~6000 tokens
   - Step 3: ~8000 tokens × (总数/批量大小)
   - Step 4: ~6000 tokens
   - 总计：约 20000 + 8000×批次数 tokens

2. **模型选择**：
   - 快速模式：使用 glm-4-flash 或 gpt-3.5-turbo
   - 质量模式：使用 glm-4 或 gpt-4
   - 流水线模式：Step 1-2 用快速模型，Step 3-4 用高质量模型

## 故障排查

### 常见问题

1. **JSON解析失败**：
   - 检查模型输出是否包含有效JSON
   - 使用正则提取JSON部分
   - 添加重试机制

2. **属性重复率高**：
   - 增加 Step 3 的去重检查力度
   - 调整 `suggestedAttributes` 的生成策略
   - 在 Step 4 中强制修正

3. **ERWX不完整**：
   - 在 Step 3 中强制要求4个子过程
   - 在 Step 4 中检查并补全缺失的子过程

## 总结

三层分析框架通过系统化的方法，解决了传统COSMIC拆分中的三大问题：
1. **FP边界清晰**：通过第一层分析，明确触发事件
2. **属性唯一**：通过第二层分析，建立字段池并确保互斥
3. **拆分完整**：通过第三层分析和膨胀策略，覆盖所有功能

四步流水线提供了可控、高质量的拆分流程，特别适合复杂业务系统的COSMIC分析。
